import { execSync } from "node:child_process"
import fs from "node:fs"
import path from "node:path"
import { fileURLToPath } from "node:url"

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const FIRMWARE_DIR = path.resolve(__dirname, "../vendor/firmware")
const OUTPUT_FILE = path.resolve(__dirname, "../constants/versions.ts")

function parseVersion(tag) {
  // Extract version from tag (e.g., "v2.6.13.0561f2c" -> {major: 2, minor: 6, patch: 13})
  const match = tag.match(/v?(\d+)\.(\d+)\.(\d+)/)
  if (match) {
    return {
      major: parseInt(match[1], 10),
      minor: parseInt(match[2], 10),
      patch: parseInt(match[3], 10),
    }
  }
  return null
}

function getVersions() {
  try {
    // Fetch tags from the meshtastic remote
    execSync("git fetch meshtastic --tags", { cwd: FIRMWARE_DIR, encoding: "utf-8" })

    // Run git tag in the firmware directory
    const output = execSync("git tag", { cwd: FIRMWARE_DIR, encoding: "utf-8" })

    // Filter and sort tags
    // We are looking for tags like v2.5.0...
    const allTags = output
      .split("\n")
      .map(tag => tag.trim())
      .filter(tag => tag.startsWith("v") && tag.includes("."))
      // Simple sort for now, ideally semver sort but string sort works okay for fixed format vX.Y.Z
      // We want reverse sort to show latest first
      .sort((a, b) => b.localeCompare(a, undefined, { numeric: true, sensitivity: "base" }))

    // Filter to only show latest patch versions of 2.6 and 2.7
    // Latest patch versions: 2.6.13 and 2.7.16
    const supportedVersions = [
      { major: 2, minor: 6, patch: 13 },
      { major: 2, minor: 7, patch: 16 },
    ]

    const isSupportedVersion = tag => {
      const version = parseVersion(tag)
      if (!version) return false
      return supportedVersions.some(
        sv => sv.major === version.major && sv.minor === version.minor && sv.patch === version.patch
      )
    }

    // Filter to only supported patch versions
    const filteredTags = allTags.filter(tag => isSupportedVersion(tag))

    return filteredTags
  } catch (error) {
    console.error("Error getting git tags:", error)
    return []
  }
}

function generateFile(versions) {
  const content = `// This file is auto-generated by scripts/generate-versions.js
export const VERSIONS = ${JSON.stringify(versions, null, "\t")} as const;

export type FirmwareVersion = typeof VERSIONS[number];
`

  fs.writeFileSync(OUTPUT_FILE, content)
  console.log(`Generated ${OUTPUT_FILE} with ${versions.length} versions`)
}

const versions = getVersions()
generateFile(versions)
